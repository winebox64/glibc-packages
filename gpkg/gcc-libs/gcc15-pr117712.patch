2025-02-27  Jakub Jelinek  <jakub@redhat.com>

	PR rtl-optimization/117712
	* expr.cc (force_operand): Handle {,UNSIGNED_}FIX with
	FIX operand using expand_fix on the inner FIX operand.

	* gcc.dg/pr117712.c: New test.

--- src/gcc/expr.cc.jj	2025-01-31 15:12:57.892489693 +0100
+++ src/gcc/expr.cc	2025-02-27 12:07:06.079581662 +0100
@@ -8747,7 +8747,19 @@ force_operand (rtx value, rtx target)
     {
       if (!target)
 	target = gen_reg_rtx (GET_MODE (value));
-      op1 = force_operand (XEXP (value, 0), NULL_RTX);
+      /* FIX or UNSIGNED_FIX with integral mode has unspecified rounding,
+	 while FIX with floating point mode rounds toward zero.  So, some
+	 targets use expressions like (fix:SI (fix:DF (reg:DF ...)))
+	 to express rounding toward zero during the conversion to int.
+	 expand_fix isn't able to handle that, it can only handle
+	 FIX/UNSIGNED_FIX from floating point mode to integral one.  */
+      if ((code == FIX || code == UNSIGNED_FIX)
+	  && GET_CODE (XEXP (value, 0)) == FIX
+	  && (GET_MODE (XEXP (value, 0))
+	      == GET_MODE (XEXP (XEXP (value, 0), 0))))
+	op1 = force_operand (XEXP (XEXP (value, 0), 0), NULL_RTX);
+      else
+	op1 = force_operand (XEXP (value, 0), NULL_RTX);
       switch (code)
 	{
 	case ZERO_EXTEND:
--- src/gcc/testsuite/gcc.dg/pr117712.c.jj	2025-02-27 11:59:55.906554128 +0100
+++ src/gcc/testsuite/gcc.dg/pr117712.c	2025-02-27 12:04:27.397775236 +0100
@@ -0,0 +1,13 @@
+/* PR rtl-optimization/117712 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -ffast-math" } */
+
+int b;
+
+int
+foo (int x)
+{
+  if (b)
+    x = 0.96 * x;
+  return x;
+}
